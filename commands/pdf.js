const PDFDocument = require("pdfkit");
const fs = require("fs");
const path = require("path");

/**
 * Generates a PDF from the provided text and sends it to the chat.
 * @param {import("@whiskeysockets/baileys").WASocket} sock
 * @param {string} chatId
 * @param {string} text
 * @param {any} message
 */
async function pdfCommand(sock, chatId, text, message) {
  let pdfPath = null;
  const tempDir = path.join(__dirname, "../temp");

  try {
    // 1. Send initial message & start animation
    const initialMsg = await sock.sendMessage(
      chatId,
      { text: "üìë Generating PDF..." },
      { quoted: message }
    );
    const key = initialMsg.key;

    // Loading animation
    const loaders = [
      "‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú 0%",
      "üü©‚¨ú‚¨ú‚¨ú‚¨ú 20%",
      "üü©üü©‚¨ú‚¨ú‚¨ú 40%",
      "üü©üü©üü©‚¨ú‚¨ú 60%",
      "üü©üü©üü©üü©‚¨ú 80%",
      "üü©üü©üü©üü©üü© 100%",
    ];

    let animationPromise = (async () => {
      for (const loader of loaders) {
        await new Promise((r) => setTimeout(r, 600)); // Delay for animation
        await sock.sendMessage(chatId, {
          text: `üìë Generating PDF...\n${loader}`,
          edit: key,
        });
      }
    })();

    console.log("‚û°Ô∏è [PDF COMMAND] Starting generation...");
    console.log(`‚û°Ô∏è [PDF COMMAND] Text length: ${text.length} characters`);

    // Ensure temp directory exists
    if (!fs.existsSync(tempDir)) {
      console.log("‚û°Ô∏è [PDF COMMAND] Creating temp directory...");
      fs.mkdirSync(tempDir, { recursive: true });
    }

    pdfPath = path.join(tempDir, `samkielbot-${Date.now()}.pdf`);
    console.log(`‚û°Ô∏è [PDF COMMAND] PDF path will be: ${pdfPath}`);

    const doc = new PDFDocument({ margin: 50 });
    const stream = fs.createWriteStream(pdfPath);

    // Error handling for stream
    stream.on("error", (err) => {
      console.error("‚ùå [PDF COMMAND] Stream Error:", err);
    });

    doc.pipe(stream);

    // Event listener to add footer to EVERY page automatically
    doc.on("pageAdded", () => {
      addFooter(doc);
    });

    // Add footer to the first page manually
    addFooter(doc);

    // Add content
    doc.fontSize(12).text(text, {
      align: "justify",
      lineGap: 2,
    });

    function addFooter(doc) {
      const oldBottomMargin = doc.page.margins.bottom;
      doc.page.margins.bottom = 0;
      const oldX = doc.x;
      const oldY = doc.y;

      doc.save();

      const bottom = doc.page.height - 50;

      doc
        .fontSize(10)
        .fillColor("black")
        .text("PDF GENERATED BY SAMKIELBOT - ", 50, bottom, {
          continued: true,
          align: "center",
          width: doc.page.width - 100,
        })
        .fillColor("blue")
        .text("www.samkielbot.app", {
          link: "https://www.samkielbot.app",
          underline: true,
        });

      doc.restore();
      doc.x = oldX;
      doc.y = oldY;
      doc.page.margins.bottom = oldBottomMargin;
    }

    console.log("‚û°Ô∏è [PDF COMMAND] Finalizing document...");
    doc.end();

    // Wait for the stream to finish writing
    await new Promise((resolve, reject) => {
      stream.on("finish", () => {
        console.log("‚û°Ô∏è [PDF COMMAND] Write stream finished.");
        resolve();
      });
      stream.on("error", (err) => {
        console.error("‚ùå [PDF COMMAND] Stream error during promise:", err);
        reject(err);
      });
    });

    // Final verification
    if (!fs.existsSync(pdfPath)) {
      throw new Error(
        "PDF file was not created successfully after stream finish."
      );
    }

    const stats = fs.statSync(pdfPath);
    console.log(`‚û°Ô∏è [PDF COMMAND] File size: ${stats.size} bytes`);

    if (stats.size === 0) {
      throw new Error("Generated PDF is empty (0 bytes).");
    }

    // Ensure animation finishes visually
    await animationPromise;

    // Delete the loading message
    await sock.sendMessage(chatId, { delete: key });

    console.log("‚û°Ô∏è [PDF COMMAND] Sending file via Baileys...");
    await sock.sendMessage(
      chatId,
      {
        document: { url: pdfPath },
        fileName: `samkielbot-pdf_${message.pushName || "User"}.pdf`,
        mimetype: "application/pdf",
        caption: "‚úÖ PDF Generated Successfully",
        contextInfo: global.channelInfo?.contextInfo || {},
      },
      { quoted: message }
    );

    console.log("‚úÖ [PDF COMMAND] PDF sent successfully.");
  } catch (error) {
    console.error("‚ùå [PDF COMMAND] Fatal Error:", error);

    // Provide user-friendly error message
    await sock.sendMessage(
      chatId,
      {
        text: `‚ùå *PDF Error*\n\nAn error occurred while generating your PDF. Please try again later.\n\n*Error:* ${error.message}`,
      },
      { quoted: message }
    );
  } finally {
    // Cleanup
    if (pdfPath && fs.existsSync(pdfPath)) {
      try {
        fs.unlinkSync(pdfPath);
        console.log("‚û°Ô∏è [PDF COMMAND] Temporary file cleaned up.");
      } catch (e) {
        console.error("‚ùå [PDF COMMAND] Cleanup error:", e);
      }
    }
  }
}

module.exports = pdfCommand;
